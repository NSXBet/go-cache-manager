package cmd

import (
	"fmt"
	"strings"
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
)

type Generator struct{}

func NewGenerator() *Generator {
	return &Generator{}
}

func (g *Generator) Generate() error {
	var err error

	protoOpt := protogen.Options{}

	protoOpt.Run(func(gen *protogen.Plugin) error {
		err = g.GenerateFiles(gen)

		return err
	})

	if err != nil {
		return fmt.Errorf("generating cache manager code: %w", err)
	}

	return nil
}

func (g *Generator) GenerateFiles(gen *protogen.Plugin) error {
	for _, f := range gen.Files {
		if f.Generate {
			if !g.hasCacheService(f) {
				continue
			}

			if ferr := g.generateFile(gen, f); ferr != nil {
				return fmt.Errorf("generating file %s: %w", f.Desc.Path(), ferr)
			}
		}
	}

	return nil
}

func (g *Generator) hasCacheService(file *protogen.File) bool {
	for _, service := range file.Services {
		if strings.HasSuffix(service.GoName, "Cache") {
			return true
		}
	}

	return false
}

func (g *Generator) generateFile(gen *protogen.Plugin, file *protogen.File) error {
	filename := file.GeneratedFilenamePrefix + "_cache_manager.pb.go"

	gf := gen.NewGeneratedFile(filename, file.GoImportPath)
	gf.P("// Code generated by protoc-gen-go-cache-manager. DO NOT EDIT.")
	gf.P()
	gf.P("package ", file.GoPackageName)
	gf.P()

	gf.P("import (")
	gf.P("	\"context\"")
	gf.P("	\"fmt\"")
	gf.P()
	gf.P("  \"github.com/NSXBet/protoc-gen-go-cache-manager/pkg/gocachemanager\"")
	gf.P(")")

	for _, service := range file.Services {
		if !strings.HasSuffix(service.GoName, "Cache") {
			continue
		}

		if serr := g.generateService(gf, service); serr != nil {
			return serr
		}
	}

	return nil
}

func (g *Generator) managerName(structname string) string {
	if len(structname) == 0 {
		return ""
	}

	return fmt.Sprintf("%sManager", structname)
}

func (g *Generator) privateManagerName(structname string) string {
	s := g.managerName(structname)

	runes := []rune(s)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}

func (g *Generator) methodName(managerName, methodName string) string {
	return fmt.Sprintf(
		"%s_%s",
		managerName,
		methodName,
	)
}

func (g *Generator) generateService(gf *protogen.GeneratedFile, service *protogen.Service) error {
	managerName := g.managerName(service.GoName)

	comments := ""
	if service.Comments.Leading != "" {
		comments = fmt.Sprintf(
			"// %s for every operation related to this service:\n%s",
			managerName,
			service.Comments.Leading.String(),
		)
	}

	gf.P(comments, "type ", managerName, " struct {")

	for _, method := range service.Methods {
		gf.P(
			"	",
			g.methodName(g.privateManagerName(method.Parent.GoName), method.GoName),
			" *gocachemanager.CacheManager[*",
			method.Input.GoIdent.GoName,
			", *",
			method.Output.GoIdent.GoName,
			"]",
		)
	}

	gf.P("}")
	gf.P()

	var constructedManagers []string

	comments = ""
	if service.Comments.Leading != "" {
		comments = fmt.Sprintf(
			"// New%s is the constructor method for this service:\n%s",
			managerName,
			service.Comments.Leading.String(),
		)
	}

	refreshMethods := []string{}
	for _, method := range service.Methods {
		refreshMethods = append(refreshMethods, fmt.Sprintf(
			"	update%sFn func(context.Context, *%s, map[string]any) (*%s, error)",
			method.GoName,
			method.Input.GoIdent.GoName,
			method.Output.GoIdent.GoName,
		))
	}

	gf.P(strings.TrimSuffix(comments, "\n"))
	gf.P("	// Required Update Method(s):")
	for _, method := range service.Methods {
		gf.P(
			"	// - update",
			method.GoName,
			"Fn is a function that loads the data from the storage and you",
		)
		gf.P(
			"	//    can pass any dependencies required to resolve it when calling the Get and Refresh methods",
		)
		gf.P("	//    and these will be available as the third argument of the method.")
	}
	gf.P(
		"func New",
		g.managerName(service.GoName),
		"(",
	)

	for _, refreshMethod := range refreshMethods {
		gf.P(refreshMethod, ",")
	}

	gf.P("  options ...gocachemanager.CacheOption,")
	gf.P(
		") (*",
		service.GoName,
		"Manager, error) {",
	)
	for _, method := range service.Methods {
		mgrs, merr := g.generateConstructorManager(gf, method)
		if merr != nil {
			return merr
		}

		constructedManagers = append(constructedManagers, mgrs...)
	}
	gf.P("	return &", g.managerName(service.GoName), " {")

	for _, mgr := range constructedManagers {
		gf.P("		", mgr, ": ", mgr, ",")
	}

	gf.P("	}, nil")
	gf.P("}")
	gf.P()

	for _, method := range service.Methods {
		if merr := g.generateMethod(gf, method); merr != nil {
			return merr
		}
	}

	return nil
}

func (g *Generator) generateConstructorManager(
	gf *protogen.GeneratedFile,
	method *protogen.Method,
) ([]string, error) {
	var mgrs []string

	gf.P(
		g.methodName(g.privateManagerName(method.Parent.GoName), method.GoName),
		", err := gocachemanager.NewCacheManager",
		"(",
	)
	gf.P(
		"\"",
		strings.ToLower(method.Parent.GoName),
		"::",
		strings.ToLower(method.GoName),
		"\",",
	)
	gf.P(
		"func() *",
		method.Output.GoIdent.GoName,
		" { return &",
		method.Output.GoIdent.GoName,
		"{} },",
	)
	gf.P(
		"update", method.GoName, "Fn,",
	)
	gf.P(
		"options...",
	)
	gf.P(")")

	gf.P("if err != nil {")
	gf.P(
		"	return nil, fmt.Errorf(\"creating cache manager %s: %w\", \"",
		method.GoName,
		"\", err)",
	)
	gf.P("}")
	gf.P()

	mgrs = append(mgrs, g.methodName(g.privateManagerName(method.Parent.GoName), method.GoName))

	return mgrs, nil
}

func (g *Generator) generateMethod(gf *protogen.GeneratedFile, method *protogen.Method) error {
	managerName := g.managerName(method.Parent.GoName)
	fieldName := g.methodName(g.privateManagerName(method.Parent.GoName), method.GoName)

	// Get cache
	comments := ""
	if method.Comments.Leading != "" {
		resultComments := []string{}
		commentLines := strings.Split(method.Comments.Leading.String(), "\n")

		for index, line := range commentLines {
			if line == "" {
				continue
			}

			comment := strings.TrimSuffix(
				strings.ReplaceAll(
					strings.ReplaceAll(line, "// ", ""),
					"//", "",
				),
				" ",
			)

			if index == 0 && strings.HasPrefix(comment, method.GoName) {
				resultComments = append(resultComments, fmt.Sprintf(
					"// Get%s",
					comment,
				))
			} else {
				resultComments = append(resultComments, fmt.Sprintf("// %s", comment))
			}
		}

		comments = strings.Join(resultComments, "\n")
	}

	gf.P(comments)
	gf.P(
		"func (cm *",
		managerName,
		") Get",
		method.GoName,
		"(",
	)
	gf.P("  ctx context.Context,")
	gf.P("	input *", method.Input.GoIdent.GoName, ",")
	gf.P("	dependencies ...map[string]any,")
	gf.P(") (*", method.Output.GoIdent.GoName, ", error) {")
	gf.P("	return cm.", fieldName, ".Get(ctx, input, dependencies...)")
	gf.P("}")
	gf.P()

	// Set cache
	for _, methodPrefix := range []string{"Refresh", "Replace", "Delete"} {
		comments = ""
		if method.Comments.Leading != "" {
			comments = fmt.Sprintf(
				"// Eagerly %s the cache for the method that:\n%s",
				methodPrefix,
				method.Comments.Leading.String(),
			)
		}

		gf.P(
			comments,
			"func (cm *",
			managerName,
			") ",
			methodPrefix,
			method.GoName,
			"(",
		)
		gf.P("  ctx context.Context,")
		gf.P("	input *", method.Input.GoIdent.GoName, ",")

		if methodPrefix == "Replace" {
			gf.P("	newValue *", method.Output.GoIdent.GoName, ",")
		}

		gf.P("	dependencies ...map[string]any,")
		if methodPrefix == "Delete" {
			gf.P(") error {")
		} else {
			gf.P(") (*", method.Output.GoIdent.GoName, ", error) {")
		}
		gf.P("	return cm.", fieldName, ".", methodPrefix, "(")
		gf.P("	ctx,")
		gf.P("	input, ")

		if methodPrefix == "Replace" {
			gf.P("newValue, ")
		}

		gf.P("	dependencies...,")
		gf.P(")")
		gf.P("}")
		gf.P()
	}

	return nil
}
